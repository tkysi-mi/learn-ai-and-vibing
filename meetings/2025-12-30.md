# バイブコーディング勉強会 2025-12-30

## 「仕様駆動開発 ― Spec Kit を使った AI 開発ワークフロー」

---

# アジェンダ

1. 前回の振り返り
2. コンテキストエンジニアリング
3. 仕様駆動開発と Spec Kit
4. ハンズオン
5. （時間があれば）コード品質の自動担保

---

# 1. 前回の振り返り

前回は、Windsurf を使って「まず動くものを作る」ことに取り組みました。

実施した内容は以下のとおりです。

- Windsurf のインストールと環境構築
- node.js(npm)、python(uv)等のパッケージマネージャーの準備
- MCP の設定
- タスク管理ツールをデモで作成
  - フロント、バック両方が JS のもの
  - https://github.com/nino-space/practice-001
- Web アプリの知識がないと正しいものが作れているのか分からないので、知識を付ける
  - 【世界で 90 万人が受講】Web Developer Bootcamp（日本語版）

実際に動くものができました。

ただし、あのとき作成したものが「正しいもの」だったかというと、判断が難しいところです。

本日は、その曖昧さをどのように解消するかを扱います。

---

# 2. コンテキストエンジニアリング

## コンテキストウィンドウとは

AI には「コンテキストウィンドウ」と呼ばれる制約があります。

これは、AI が一度に処理できる情報量の上限です。人間で言えば「短期記憶」や「作業机の広さ」に近い概念です。

### トークンという単位

コンテキストウィンドウのサイズは「トークン」という単位で測られます。

トークンは、おおよそ以下の目安です。

- 英語：1 単語 ≒ 1 トークン
- 日本語：1 文字 ≒ 1〜2 トークン

例えば「タスク管理アプリを作成してください」という文は、約 20〜30 トークン程度です。

### 具体的なサイズ

主要な AI モデルのコンテキストウィンドウは以下のとおりです。

| モデル         | コンテキストウィンドウ | 目安                     |
| -------------- | ---------------------- | ------------------------ |
| GPT-4o         | 128,000 トークン       | 日本語で約 6〜8 万文字   |
| Claude 3.5     | 200,000 トークン       | 日本語で約 10〜12 万文字 |
| Gemini 1.5 Pro | 1,000,000 トークン     | 日本語で約 50〜60 万文字 |

大きいように見えますが、会話の履歴、参照ファイル、AI の出力など、すべてがこの枠を消費します。具体的に何が消費するかは、後述の「コンテキストを構成する要素」で詳しく説明します。

### ウィンドウが溢れるとどうなるか

コンテキストウィンドウを超えると、古い情報から順に「見えなくなります」。

```
[ウィンドウの外] ← AIには見えない
--------------------
| 最初の指示      |
| 仕様書の前半    |
--------------------

[ウィンドウの中] ← AIにはここだけ見える
--------------------
| 仕様書の後半    |
| 最近の会話      |
| 今の質問        |
--------------------
```

つまり、長い会話を続けていると、最初に伝えた重要な指示を AI が「忘れる」ことがあります。

### なぜ重要か

コンテキストウィンドウの制約は、以下の問題を引き起こします。

**問題 1：最初の指示が消える**

長い開発作業の途中で、最初に伝えたプロジェクトの原則や仕様を AI が参照できなくなります。結果、一貫性のないコードが生成されます。

**問題 2：大きな仕様を一度に渡せない**

仕様書全体、設計書全体をまとめて渡すと、それだけでウィンドウの大部分を消費します。AI が出力できる余地が減り、品質が低下します。

**問題 3：参照ファイルが多すぎると破綻する**

「このファイルも読んで」「あのファイルも参照して」と追加していくと、すぐに上限に達します。

### 対策

これらの問題に対処するため、以下の工夫が必要です。

- **仕様を分割する**：1 回の指示で完結する単位に分ける
- **原則を別ファイルで管理する**：Spec Kit の`constitution.md`のように、常に参照される仕組みを使う
- **会話をリセットする**：長くなったら新しい会話を開始し、必要な情報だけを再度渡す

この制約があるからこそ、「何を渡すか」の設計が重要になります。

## AI とエンジニアの違い

従来の開発プロセスとの違いを整理します。

### エンジニアに仕様を渡したとき

従来は、皆さんが仕様書を作成し、エンジニアに渡していました。

仕様書に曖昧な部分があった場合、エンジニアは以下のように対応していました。

| 状況                     | エンジニアの対応                                         |
| ------------------------ | -------------------------------------------------------- |
| 画面遷移が書かれていない | 「モーダルにしますか？別ページにしますか？」と質問       |
| エラー処理が未定義       | 「エラー時はトースト通知で良いですか？」と確認           |
| 技術的に実現困難         | 「この方法だと難しいので、代替案を提案します」と相談     |
| 業界の慣例がある         | 「この機能は通常こう作るので、そうしておきますね」と補完 |

つまり、エンジニアは以下の役割を担っていました。

- **質問者**：不明点を確認してくれる
- **提案者**：より良い方法を提案してくれる
- **補完者**：経験に基づいて行間を埋めてくれる

### AI に仕様を渡したとき

AI は異なります。

| 状況                     | AI の対応                                                |
| ------------------------ | -------------------------------------------------------- |
| 画面遷移が書かれていない | 勝手にモーダルか別ページか決めて実装                     |
| エラー処理が未定義       | 勝手に console.log だけにするか、アラートにするか決める  |
| 技術的に実現困難         | そのまま実装しようとして失敗、または勝手に別の方法で実装 |
| 業界の慣例がある         | 知らない場合は独自の方法で実装                           |

AI は基本的に**質問せずに実装を進めます**。

- 不明点があっても、自分で解釈して進める
- 「たぶんこういうことだろう」と推測して作る
- 結果として、意図と異なるものができる

### 根本的な違い

| 観点           | エンジニア                   | AI                   |
| -------------- | ---------------------------- | -------------------- |
| 不明点への対応 | 質問する                     | 推測して進める       |
| 業務知識       | 持っている（または学習する） | 持っていない         |
| 文脈の理解     | 組織の事情を考慮できる       | 渡された情報のみ     |
| 責任感         | 「これで良いのか」と考える   | 指示どおりに生成する |

エンジニアは「対話しながら作る」存在でしたが、AI は「渡された情報だけで作る」存在です。

だからこそ、**AI には曖昧さを残さずに伝える必要があります**。

## コンテキストエンジニアリングとは

### 定義

コンテキストエンジニアリングは、2024 年後半から注目されている概念です。

Shopify CEO の Tobi Lutke は以下のように定義しています。

> 「タスクを LLM が解決可能にするために、すべてのコンテキストを提供する技術」

LangChain の創設者は、より具体的に定義しています。

> 「適切な情報とツールを、適切なフォーマットで提供し、LLM がタスクを達成できるようにする動的なシステムを構築すること」

重要なのは「動的なシステム」という点です。単にプロンプトを書くのではなく、**必要な情報を自動的に収集・整理して AI に渡す仕組み**を設計することを指します。

### プロンプトエンジニアリングとの違い

| 観点 | プロンプトエンジニアリング | コンテキストエンジニアリング |
| ---- | -------------------------- | ---------------------------- |
| 焦点 | どのように聞くか           | 何を渡すか                   |
| 対象 | 単一のプロンプト           | AI が見るすべての情報        |
| 性質 | 静的（固定の文章）         | 動的（状況に応じて変化）     |
| 範囲 | 指示の書き方               | システム全体の設計           |

プロンプトエンジニアリングは、コンテキストエンジニアリングの一部です。良いプロンプトを書くことは依然として重要ですが、それだけでは不十分になってきています。

### コンテキストを構成する要素

AI が「見ている」情報は、以下の要素で構成されています。これらすべてがコンテキストウィンドウを消費します。

| 要素               | 説明                        | 例                                       | 消費量の目安     |
| ------------------ | --------------------------- | ---------------------------------------- | ---------------- |
| システムプロンプト | AI の振る舞いを定義する指示 | 「あなたはタスク管理アプリの開発者です」 | 小〜中           |
| ユーザーの入力     | 今回のリクエスト            | 「タスクの削除機能を追加して」           | 小               |
| 会話履歴           | これまでのやり取り          | 過去の質問と回答                         | 大（蓄積される） |
| 参照ファイル       | @で渡したファイル           | 仕様書、設計書                           | 大               |
| ツール定義         | AI が使えるツールの説明     | 「ファイル作成ツール」「検索ツール」     | 中               |
| ツール実行結果     | ツールを使った結果          | ファイルの内容、検索結果                 | 中〜大           |
| AI の出力          | 生成されるコード            | 実装コード                               | 大               |

会話が長くなると履歴が蓄積され、参照ファイルを追加するとさらに消費が増えます。このバランスを考えながら、何を渡すかを設計する必要があります。

### なぜ今、重要なのか

AI エージェントの開発が進む中で、以下の認識が広まっています。

**「エージェントの失敗のほとんどは、モデルの失敗ではなく、コンテキストの失敗である」**

AI の性能が向上しても、適切な情報を渡さなければ、AI は適切に動作しません。

つまり、コンテキストエンジニアリングとは以下の問いに答えることです。

- **何を**渡すか（どの情報が必要か）
- **いつ**渡すか（どのタイミングで必要か）
- **どのように**渡すか（どんなフォーマットが最適か）

本日扱う Spec Kit は、このコンテキストエンジニアリングを仕様駆動開発の文脈で実践するためのツールです。

## AI に伝わる仕様 / 伝わらない仕様

皆さんは上流工程の経験をお持ちですので、「タスク管理アプリを作って」とだけ指示することはないはずです。

機能一覧程度は記載されるでしょう。例えば以下のような形式です。

**よくある仕様の渡し方：**

```
タスク管理アプリを作成してください。

機能：
- タスクの追加
- 完了チェック
- 削除
- カテゴリ分類

技術：React + TypeScript
```

機能要件は伝わっています。しかし、**これだけでは不足している情報があります**。

**不足している情報：**

| 項目         | 記載されていない内容                           |
| ------------ | ---------------------------------------------- |
| 画面一覧     | 画面数は？一覧と詳細は分離する？               |
| 画面遷移     | どこからどこへ遷移する？モーダル？ページ遷移？ |
| データモデル | タスクの属性は？期限は？優先度は？             |
| API 設計     | エンドポイントの構成は？RESTful？              |
| 状態管理     | データの保存先は？ローカル？サーバー？         |

従来の開発であれば、エンジニアが「画面遷移はどうしますか」と確認してくれました。

AI は異なります。**確認せずに、独自の解釈で実装を進めます。**

同じ機能要件を渡しても、AI の解釈によって全く異なるものが生成されます。

**AI-A の解釈：**

- 1 画面完結のシンプルなリスト形式
- ローカルストレージでデータ保存
- 最小限の CRUD 機能

**AI-B の解釈：**

- 3 画面構成（一覧/詳細/編集）
- SQLite によるデータベース構築
- 「あると便利だろう」と優先度機能を追加

どちらも「タスク管理アプリ」として誤りではありません。しかし、意図したものと異なる可能性があります。

コンテキストエンジニアリングの本質は、**「AI に解釈させない」こと**です。曖昧さを排除するほど、意図した成果物が得られます。

---

# 3. 仕様駆動開発と Spec Kit

## 仕様駆動開発（Spec-Driven Development）とは

従来の開発では、仕様書は「足場」のようなものでした。コードを書き始めると、仕様書は役目を終えて放置されることも多かったはずです。

仕様駆動開発は、この関係を逆転させます。

**仕様そのものが実装を駆動する。**

仕様を明確に定義し、AI がその仕様から直接コードを生成する。仕様が曖昧であれば、生成されるコードも曖昧になります。

## Spec Kit とは

Spec Kit は GitHub が開発したオープンソースのツールキットです。仕様駆動開発のワークフローを支援します。

https://github.com/github/spec-kit

主な特徴は以下のとおりです。

- CLI ツール「specify」でプロジェクトを初期化
- スラッシュコマンドでワークフローを進行
- Windsurf を含む主要な AI IDE に対応

## Spec Kit のワークフロー

Spec Kit は 5 つのステップで構成されています。

### ステップ 1：/speckit.constitution

プロジェクトの原則を定義します。コード品質、テスト基準、UX の一貫性など、開発全体を通じて守るべきガイドラインを設定します。

これは一度設定すれば、以降の開発で AI が常に参照します。

### ステップ 2：/speckit.specify

何を作りたいかを定義します。「何を」「なぜ」に焦点を当て、技術スタックには言及しません。

ここで重要なのは、ユーザーストーリーと機能要件を明確にすることです。

### ステップ 3：/speckit.plan

技術スタックとアーキテクチャを決定します。「どうやって作るか」をここで初めて指定します。

出力として、データモデル、API 設計、実装計画などが生成されます。

### ステップ 4：/speckit.tasks

実装計画をタスクに分解します。依存関係を考慮した順序で、具体的な作業単位に落とし込みます。

各タスクには、実装すべきファイルパスや検証ポイントが含まれます。

### ステップ 5：/speckit.implement

タスクを順番に実行し、実装を進めます。AI がタスクリストに従ってコードを生成します。

## Windsurf での基本操作

スラッシュコマンド、@参照、rules ファイルについては前回扱ったため、本日は省略します。

---

# 4. ハンズオン

Spec Kit を使って、ゼロからタスク管理アプリの仕様を作成します。

## 事前準備

### uv のインストール確認

Spec Kit のインストールには uv が必要です。ターミナルで以下を実行し、インストールされているか確認します。

```
uv --version
```

インストールされていない場合は、以下でインストールします。

**Mac/Linux：**

```
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**Windows（PowerShell）：**

```
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```

### Spec Kit のインストール

以下のコマンドで Spec Kit をインストールします。

```
uv tool install specify-cli --from git+https://github.com/github/spec-kit.git
```

インストール後、以下で確認します。

```
specify check
```

## 手順 1：プロジェクトの作成

任意の場所に新しいプロジェクトを作成します。

```
specify init task-manager --ai windsurf
```

プロジェクトフォルダに移動します。

```
cd task-manager
```

Windsurf でプロジェクトを開きます。

```
windsurf .
```

Windsurf のチャット欄で `/speckit.` と入力し、コマンド一覧が表示されることを確認します。

## 手順 2：プロジェクト原則の定義（/speckit.constitution）

Windsurf のチャット欄で以下を入力します。

```
/speckit.constitution
```

続けて、プロジェクトの原則を入力します。

```
以下の原則でプロジェクトを進める。

コード品質：
- コメントは日本語で記述する
- 関数には目的を説明するドキュメントコメントを付与する

UI/UX：
- シンプルさを優先する
- 1画面で完結することを目指す
- 日本語UIとする

技術方針：
- 外部ライブラリは最小限に抑える
- 標準APIを優先して使用する
```

実行後、`.specify/memory/constitution.md` が生成されます。

## 手順 3：仕様の定義（/speckit.specify）

チャット欄で以下を入力します。

```
/speckit.specify
```

続けて、作りたいものを説明します。技術的な話は含めず、「何を」「なぜ」に集中します。

```
個人用のタスク管理アプリを作成する。

目的：
日々のタスクを管理し、完了状況を把握できるようにする。

ユーザー：
自分一人で使用する。ログイン機能は不要。

必要な機能：
- タスクの追加：テキストを入力してタスクを作成できる
- タスクの完了：チェックを付けて完了状態にできる
- タスクの削除：不要なタスクを削除できる
- タスクの一覧表示：すべてのタスクをリスト形式で表示する

画面構成：
- 1画面のみで構成する
- 画面上部にタスク追加フォームを配置する
- その下にタスク一覧を表示する
- 完了したタスクは取り消し線で表示する

データの保存：
- ブラウザを閉じてもデータが消えないようにする
```

実行後、`.specify/specs/001-task-manager/spec.md` が生成されます。

生成された仕様書を確認し、不足があれば追加で指示します。

## 手順 4：技術計画の策定（/speckit.plan）

チャット欄で以下を入力します。

```
/speckit.plan
```

続けて、技術的な要件を指定します。

```
以下の技術スタックで実装する。

フレームワーク：
- React + TypeScript
- ビルドツール：Vite

スタイリング：
- Tailwind CSS

データ保存：
- ブラウザのローカルストレージを使用
- サーバーサイドは不要

データモデル：
- Task
  - id: string（UUID）
  - title: string（タスクのタイトル）
  - completed: boolean（完了状態）
  - createdAt: Date（作成日時）
```

実行後、以下のファイルが生成されます。

- `plan.md`：実装計画
- `data-model.md`：データモデル定義
- その他、必要に応じて追加ファイル

生成された計画を確認します。過剰な機能が含まれていないか、指定した技術スタックと一致しているかを確認します。

## 手順 5：タスク分解（/speckit.tasks）

チャット欄で以下を入力します。

```
/speckit.tasks
```

実行後、`tasks.md` が生成されます。

このファイルには、実装すべきタスクが依存関係を考慮した順序で記載されています。

内容を確認し、タスクの粒度や順序に問題がないかを確認します。

## 手順 6：実装（/speckit.implement）

チャット欄で以下を入力します。

```
/speckit.implement
```

AI がタスクリストに従って順番に実装を進めます。

実装中にエラーが発生した場合は、エラーメッセージを AI に伝えて解決を依頼します。

## 手順 7：動作確認

実装が完了したら、アプリケーションを起動して動作を確認します。

```
npm run dev
```

ブラウザで表示された URL にアクセスし、以下を確認します。

- タスクを追加できるか
- タスクを完了状態にできるか
- タスクを削除できるか
- ブラウザをリロードしてもデータが残っているか

## 振り返り

ここまでのワークフローを振り返ります。

| ステップ | コマンド              | 目的                         |
| -------- | --------------------- | ---------------------------- |
| 1        | /speckit.constitution | プロジェクト原則の定義       |
| 2        | /speckit.specify      | 仕様の定義（何を・なぜ）     |
| 3        | /speckit.plan         | 技術計画の策定（どうやって） |
| 4        | /speckit.tasks        | タスク分解                   |
| 5        | /speckit.implement    | 実装                         |

仕様を明確にしてから AI に実装させることで、意図したものが生成されやすくなります。

---

# 5. （時間があれば）コード品質の自動担保

## rules ファイルとの違い

前回、rules ファイルを紹介しました。プロジェクト全体のルールを AI に伝える仕組みです。

ただし、rules ファイルには限界があります。AI への「お願い」に過ぎないため、AI が従わないこともあります。

ここで紹介するツール群は、機械的な「強制」です。AI が生成したコードに対して、必ず適用されます。

| 仕組み              | 性質   | 動作                                    |
| ------------------- | ------ | --------------------------------------- |
| rules ファイル      | お願い | AI が解釈して従う（従わないこともある） |
| Linter/Formatter 等 | 強制   | 自動でチェック・修正される              |

## コード品質ツールの全体像

JavaScript/TypeScript の開発でよく使われるツールを紹介します。

| ツール   | 役割                         | タイミング           |
| -------- | ---------------------------- | -------------------- |
| ESLint   | コードの問題を検出           | 開発中・保存時       |
| Prettier | コードを自動整形             | 開発中・保存時       |
| Knip     | 未使用コード・依存関係の検出 | 定期的なメンテナンス |
| Husky    | Git コミット時に自動チェック | コミット時           |

### ESLint（Linter）

コードの問題を検出します。

- 未使用の変数がある
- 定義されていない関数を呼び出している
- 非推奨の書き方をしている

### Prettier（Formatter）

コードを自動整形します。

- インデントを揃える
- 行末のセミコロンを統一する
- クォートの種類を統一する

### Knip

未使用のコードや依存関係を検出します。

- 使われていないファイル
- 使われていないエクスポート
- package.json に書いてあるが使われていないライブラリ

AI が生成したコードには不要なものが含まれることがあるため、定期的なクリーンアップに有効です。

### Husky

Git でコミットする際に、自動でチェックを実行します。

- コミット前に ESLint/Prettier を実行
- 問題があればコミットをブロック
- チーム開発でルールを強制できる

## なぜ非エンジニアに必要か

AI が生成したコードは、毎回スタイルが異なることがあります。また、不要なコードが残ることもあります。

これらのツールを設定しておけば、AI が生成したコードも自動的にルールに従います。「何が正しいか」を自分で判断する必要がなくなります。

詳細な設定方法や活用方法は、次回扱います。

---

# まとめ

本日学んだ内容を振り返ります。

**コンテキストエンジニアリング：**

- AI は与えられたコンテキストの中でしか動けない
- 曖昧さを排除するほど、意図した成果物が得られる

**仕様駆動開発：**

- 仕様そのものが実装を駆動する
- Spec Kit が提供する 5 つのステップで構造化

**Spec Kit のワークフロー：**

| ステップ | コマンド              | 目的                   |
| -------- | --------------------- | ---------------------- |
| 1        | /speckit.constitution | 原則                   |
| 2        | /speckit.specify      | 仕様（何を・なぜ）     |
| 3        | /speckit.plan         | 技術計画（どうやって） |
| 4        | /speckit.tasks        | タスク分解             |
| 5        | /speckit.implement    | 実装                   |

**コード品質ツール（時間があれば）：**

- rules ファイルは AI への「お願い」、Linter 等は「強制」
- ESLint、Prettier、Knip、Husky などのツール群がある

前回は「まず動くものを作る」でした。
今回は「仕様を定義して、意図通りに作る」です。

次回は「AI が生成したコードをどのようにレビューするか」を扱う予定です。

---

# 参考リンク

- Spec Kit: https://github.com/github/spec-kit
- 前回のデモリポジトリ: https://github.com/nino-space/practice-001
- Udemy 講座: 【世界で 90 万人が受講】Web Developer Bootcamp（日本語版）

**コンテキストエンジニアリング関連：**

- The New Skill in AI is Not Prompting, It's Context Engineering: https://www.philschmid.de/context-engineering
- The rise of "context engineering" (LangChain): https://blog.langchain.com/the-rise-of-context-engineering/
- Context Engineering Guide: https://www.promptingguide.ai/guides/context-engineering-guide
